#!/bin/bash

# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
#
# üèóÔ∏è SCHEMA MANAGER: Gerenciador Inteligente de Schemas
# Objetivo: Criar tabelas e configurar sharding baseado em arquivos YAML

set -euo pipefail

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Configura√ß√µes
COMPOSE_PROJECT_NAME="citus_cluster_ha"
CONFIG_DIR="config"
SCENARIOS_DIR="$CONFIG_DIR/scenarios"
COORDINATOR_CONTAINER="citus_coordinator_primary"

# Fun√ß√£o para logs formatados
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%H:%M:%S')
    
    case $level in
        "INFO")  echo -e "${CYAN}[$timestamp] ‚ÑπÔ∏è  $message${NC}" ;;
        "SUCCESS") echo -e "${GREEN}[$timestamp] ‚úÖ $message${NC}" ;;
        "WARNING") echo -e "${YELLOW}[$timestamp] ‚ö†Ô∏è  $message${NC}" ;;
        "ERROR") echo -e "${RED}[$timestamp] ‚ùå $message${NC}" ;;
        "DEBUG") echo -e "${PURPLE}[$timestamp] üîç $message${NC}" ;;
    esac
}

# Fun√ß√£o para verificar depend√™ncias
check_dependencies() {
    log "INFO" "Verificando depend√™ncias..."
    
    # Verificar se yq est√° instalado (para parsing YAML)
    if ! command -v yq &> /dev/null; then
        log "WARNING" "yq n√£o encontrado. Tentando instalar..."
        if command -v brew &> /dev/null; then
            brew install yq
        else
            log "ERROR" "Por favor, instale yq: https://github.com/mikefarah/yq"
            log "INFO" "macOS: brew install yq"
            log "INFO" "Linux: wget -qO- https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 > /usr/local/bin/yq && chmod +x /usr/local/bin/yq"
            return 1
        fi
    fi
    
    # Verificar Docker
    if ! docker ps > /dev/null 2>&1; then
        log "ERROR" "Docker n√£o est√° rodando ou n√£o est√° acess√≠vel"
        return 1
    fi
    
    # Verificar se cluster est√° rodando
    if ! docker exec "$COORDINATOR_CONTAINER" pg_isready -U postgres > /dev/null 2>&1; then
        log "ERROR" "Cluster Citus n√£o est√° rodando. Execute docker-compose up primeiro"
        return 1
    fi
    
    log "SUCCESS" "Todas as depend√™ncias verificadas"
}

# Fun√ß√£o para listar cen√°rios dispon√≠veis
list_scenarios() {
    log "INFO" "Cen√°rios dispon√≠veis:"
    echo
    
    for scenario_file in "$SCENARIOS_DIR"/*.yml; do
        if [[ -f "$scenario_file" ]]; then
            local scenario_name=$(basename "$scenario_file" .yml)
            local description=$(yq eval '.scenario.description // "Sem descri√ß√£o"' "$scenario_file")
            local complexity=$(yq eval '.scenario.complexity // "unknown"' "$scenario_file")
            
            case $complexity in
                "beginner") complexity_icon="üü¢" ;;
                "intermediate") complexity_icon="üü°" ;;
                "advanced") complexity_icon="üî¥" ;;
                *) complexity_icon="‚ö™" ;;
            esac
            
            echo -e "  ${complexity_icon} ${BOLD}${scenario_name}${NC}: $description"
        fi
    done
    echo
}

# Fun√ß√£o para parsing do arquivo YAML
parse_yaml_config() {
    local config_file="$1"
    
    log "INFO" "Analisando configura√ß√£o: $config_file"
    
    # Verificar se arquivo existe
    if [[ ! -f "$config_file" ]]; then
        log "ERROR" "Arquivo de configura√ß√£o n√£o encontrado: $config_file"
        return 1
    fi
    
    # Extrair nome do banco
    DB_NAME=$(yq eval '.database.name // "test_db"' "$config_file")
    log "DEBUG" "Database: $DB_NAME"
    
    # Verificar se tem import de tabelas
    local import_file=$(yq eval '.import // ""' "$config_file")
    if [[ -n "$import_file" && "$import_file" != "null" ]]; then
        # Resolver caminho relativo
        import_file="$CONFIG_DIR/$import_file"
        if [[ ! -f "$import_file" ]]; then
            import_file="$CONFIG_DIR/tables.yml"  # Fallback
        fi
        log "DEBUG" "Importando defini√ß√µes de: $import_file"
        TABLES_CONFIG="$import_file"
    else
        TABLES_CONFIG="$config_file"
    fi
}

# Fun√ß√£o para criar database
create_database() {
    local db_name="$1"
    
    log "INFO" "Criando database: $db_name"
    
    # Verificar se database j√° existe
    if docker exec "$COORDINATOR_CONTAINER" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "$db_name"; then
        log "WARNING" "Database '$db_name' j√° existe. Removendo..."
        docker exec "$COORDINATOR_CONTAINER" psql -U postgres -c "DROP DATABASE IF EXISTS $db_name;"
    fi
    
    # Criar database
    docker exec "$COORDINATOR_CONTAINER" psql -U postgres -c "CREATE DATABASE $db_name;"
    
    # Criar extens√£o Citus
    docker exec "$COORDINATOR_CONTAINER" psql -U postgres -d "$db_name" -c "CREATE EXTENSION IF NOT EXISTS citus;"
    
    log "SUCCESS" "Database '$db_name' criado com extens√£o Citus"
}

# Fun√ß√£o para criar uma tabela baseada na configura√ß√£o YAML
create_table() {
    local table_name="$1"
    local config_file="$2"
    
    log "INFO" "Criando tabela: $table_name"
    
    # Extrair configura√ß√£o da tabela
    local table_type=$(yq eval ".tables.${table_name}.type" "$config_file")
    local description=$(yq eval ".tables.${table_name}.description" "$config_file")
    
    log "DEBUG" "Tipo: $table_type | Descri√ß√£o: $description"
    
    # Construir DDL
    local ddl="CREATE TABLE $table_name ("
    
    # Adicionar colunas
    local columns_count=$(yq eval ".tables.${table_name}.columns | length" "$config_file")
    for ((i=0; i<columns_count; i++)); do
        local col_name=$(yq eval ".tables.${table_name}.columns[$i].name" "$config_file")
        local col_type=$(yq eval ".tables.${table_name}.columns[$i].type" "$config_file")
        local col_desc=$(yq eval ".tables.${table_name}.columns[$i].description // \"\"" "$config_file")
        
        ddl="$ddl\n    $col_name $col_type"
        [[ $i -lt $((columns_count-1)) ]] && ddl="$ddl,"
        
        log "DEBUG" "  Coluna: $col_name ($col_type)"
    done
    
    # Verificar chave prim√°ria personalizada
    local pk=$(yq eval ".tables.${table_name}.primary_key // []" "$config_file")
    if [[ "$pk" != "[]" && "$pk" != "null" ]]; then
        local pk_cols=$(yq eval ".tables.${table_name}.primary_key | join(\", \")" "$config_file")
        ddl="$ddl,\n    PRIMARY KEY ($pk_cols)"
        log "DEBUG" "  Chave prim√°ria: $pk_cols"
    fi
    
    ddl="$ddl\n);"
    
    # Executar DDL
    log "DEBUG" "Executando DDL para $table_name"
    echo -e "$ddl" | docker exec -i "$COORDINATOR_CONTAINER" psql -U postgres -d "$DB_NAME"
    
    # Configurar distribui√ß√£o
    configure_table_distribution "$table_name" "$config_file"
    
    # Criar √≠ndices
    create_table_indexes "$table_name" "$config_file"
    
    log "SUCCESS" "Tabela '$table_name' criada com sucesso"
}

# Fun√ß√£o para configurar distribui√ß√£o da tabela
configure_table_distribution() {
    local table_name="$1"
    local config_file="$2"
    
    local table_type=$(yq eval ".tables.${table_name}.type" "$config_file")
    
    case $table_type in
        "reference")
            log "INFO" "Configurando '$table_name' como tabela de refer√™ncia"
            docker exec "$COORDINATOR_CONTAINER" psql -U postgres -d "$DB_NAME" \
                -c "SELECT create_reference_table('$table_name');"
            ;;
            
        "distributed")
            local shard_key=$(yq eval ".tables.${table_name}.shard_key" "$config_file")
            local shard_count=$(yq eval ".tables.${table_name}.shard_count // 4" "$config_file")
            
            # Verificar co-localiza√ß√£o antes de criar
            local colocated_with=$(yq eval ".tables.${table_name}.colocated_with // \"\"" "$config_file")
            
            if [[ -n "$colocated_with" && "$colocated_with" != "null" ]]; then
                log "INFO" "Configurando '$table_name' como tabela distribu√≠da co-localizada com '$colocated_with'"
                docker exec "$COORDINATOR_CONTAINER" psql -U postgres -d "$DB_NAME" \
                    -c "SELECT create_distributed_table('$table_name', '$shard_key', colocate_with => '$colocated_with');"
            else
                log "INFO" "Configurando '$table_name' como tabela distribu√≠da (shard_key: $shard_key, shards: $shard_count)"
                docker exec "$COORDINATOR_CONTAINER" psql -U postgres -d "$DB_NAME" \
                    -c "SELECT create_distributed_table('$table_name', '$shard_key', shard_count => $shard_count);"
            fi
            ;;
            
        "local")
            log "INFO" "Mantendo '$table_name' como tabela local (n√£o distribu√≠da)"
            ;;
            
        *)
            log "WARNING" "Tipo de tabela desconhecido: $table_type. Mantendo como local"
            ;;
    esac
}

# Fun√ß√£o para criar √≠ndices
create_table_indexes() {
    local table_name="$1"
    local config_file="$2"
    
    local indexes_count=$(yq eval ".tables.${table_name}.indexes | length" "$config_file" 2>/dev/null || echo "0")
    
    if [[ "$indexes_count" -gt 0 ]]; then
        log "INFO" "Criando √≠ndices para '$table_name'"
        
        for ((i=0; i<indexes_count; i++)); do
            local idx_name=$(yq eval ".tables.${table_name}.indexes[$i].name" "$config_file")
            local idx_columns=$(yq eval ".tables.${table_name}.indexes[$i].columns | join(\", \")" "$config_file")
            
            log "DEBUG" "  √çndice: $idx_name ($idx_columns)"
            
            docker exec "$COORDINATOR_CONTAINER" psql -U postgres -d "$DB_NAME" \
                -c "CREATE INDEX IF NOT EXISTS $idx_name ON $table_name ($idx_columns);"
        done
    fi
}

# Fun√ß√£o principal para criar schema completo
create_schema() {
    local scenario="$1"
    local config_file="$SCENARIOS_DIR/${scenario}.yml"
    
    log "INFO" "üöÄ Iniciando cria√ß√£o de schema para cen√°rio: $scenario"
    
    # Verificar depend√™ncias
    check_dependencies || return 1
    
    # Parse da configura√ß√£o
    parse_yaml_config "$config_file" || return 1
    
    # Criar database
    create_database "$DB_NAME"
    
    # Obter lista de tabelas na ordem correta
    local tables=$(yq eval '.tables | keys | .[]' "$TABLES_CONFIG")
    
    log "INFO" "Tabelas a serem criadas: $(echo $tables | tr '\n' ' ')"
    
    # Criar tabelas em ordem (refer√™ncia primeiro, depois distribu√≠das)
    echo "$tables" | while read -r table; do
        [[ -n "$table" && "$table" != "null" ]] && create_table "$table" "$TABLES_CONFIG"
    done
    
    # Mostrar resumo final
    show_schema_summary
    
    log "SUCCESS" "üéâ Schema criado com sucesso!"
}

# Fun√ß√£o para mostrar resumo do schema
show_schema_summary() {
    log "INFO" "üìä Resumo do Schema"
    
    echo -e "\n${CYAN}Tabelas criadas:${NC}"
    docker exec "$COORDINATOR_CONTAINER" psql -U postgres -d "$DB_NAME" -c "
    SELECT 
        schemaname,
        tablename,
        CASE 
            WHEN tablename IN (SELECT logicalrelid::regclass::text FROM pg_dist_partition) 
            THEN 'Distribu√≠da'
            WHEN tablename IN (SELECT logicalrelid::regclass::text FROM pg_dist_partition WHERE partmethod = 'n')
            THEN 'Refer√™ncia'  
            ELSE 'Local'
        END as tipo
    FROM pg_tables 
    WHERE schemaname = 'public'
    ORDER BY tablename;
    "
    
    echo -e "\n${CYAN}Distribui√ß√£o de shards:${NC}"
    docker exec "$COORDINATOR_CONTAINER" psql -U postgres -d "$DB_NAME" -c "
    SELECT 
        p.logicalrelid::regclass as tabela,
        COUNT(s.shardid) as shards,
        CASE 
            WHEN p.partkey IS NULL THEN 'N/A (tabela de refer√™ncia)'
            ELSE 'company_id'  -- Assumindo que todas usam company_id como shard key
        END as shard_key
    FROM pg_dist_shard s
    JOIN pg_dist_partition p ON s.logicalrelid = p.logicalrelid
    GROUP BY p.logicalrelid, p.partkey
    ORDER BY p.logicalrelid;
    " 2>/dev/null || log "DEBUG" "Nenhuma tabela distribu√≠da encontrada"
}

# Fun√ß√£o para modo interativo
interactive_mode() {
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë              üèóÔ∏è  SCHEMA MANAGER INTERATIVO            ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo
    
    list_scenarios
    
    echo -n -e "${CYAN}Escolha um cen√°rio para criar: ${NC}"
    read -r scenario
    
    if [[ -f "$SCENARIOS_DIR/${scenario}.yml" ]]; then
        create_schema "$scenario"
    else
        log "ERROR" "Cen√°rio '$scenario' n√£o encontrado"
        return 1
    fi
}

# Fun√ß√£o principal
main() {
    case "${1:-}" in
        "list"|"ls")
            list_scenarios
            ;;
        "create")
            if [[ -n "${2:-}" ]]; then
                create_schema "$2"
            else
                log "ERROR" "Uso: $0 create <cenario>"
                list_scenarios
                return 1
            fi
            ;;
        "interactive"|"")
            interactive_mode
            ;;
        "help"|"-h"|"--help")
            echo -e "${BOLD}Schema Manager - Gerenciador de Schemas Citus${NC}"
            echo
            echo "Uso:"
            echo "  $0 [comando] [op√ß√µes]"
            echo
            echo "Comandos:"
            echo "  list, ls              Lista cen√°rios dispon√≠veis"
            echo "  create <cenario>      Cria schema para o cen√°rio especificado"
            echo "  interactive           Modo interativo (padr√£o)"
            echo "  help                  Mostra esta ajuda"
            echo
            echo "Exemplos:"
            echo "  $0 list"
            echo "  $0 create adtech"
            echo "  $0 interactive"
            ;;
        *)
            log "ERROR" "Comando desconhecido: $1"
            echo "Use '$0 help' para ver comandos dispon√≠veis"
            return 1
            ;;
    esac
}

# Executar fun√ß√£o principal com argumentos
main "$@"
